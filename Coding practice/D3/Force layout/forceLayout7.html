<head>
	<title>Force layout test 7</title>
	<link rel="stylesheet" type="text/css" href="forceLayout.css"/>
	<style>
		.targetCircles {
			fill: none;
			stroke: gray; 
			stroke-dasharray: 5,5;
		}
	</style>
</head>
<body>
	<h1>Force Layout chart with divergent forces plus separating by colour group</h1>
	<p>Nodes are forced to different points of the screen dependant on their category. The dashed circles show where the nodes should be.</p>
	<p>In this example the node radius is "size" and the colour is "category1"</p>
	<p>Click the split button to see the nodes diverge and again to come together in the center of the chart.</p>
	<button type="button" id="splitButton">Split!</button>
	<div id="chartArea"></div>
	
	<p>Check out the source. Main code below.
	<pre class="prettyprint">
var split = false;

document.querySelector("#splitButton").addEventListener("click", function(ev){
	split = !split;	
	
	if(split) currentNodePositioner = setupSplitLayout();
	else currentNodePositioner = setupNormalLayout();
	
	forceLayouter.resume();
	
});
	
// target coordinates - presented this way for readability
var targetX1 = 300, targetY1 = 200;
var targetX2 = 900, targetY2 = 200;
var targetX3 = 300, targetY3 = 600;
var targetX4 = 600, targetY4 = 400;
	
function setupNormalLayout() {
	forceLayouter.charge(specialCharge);		
	forceLayouter.gravity(0.3);			
	
	return function(alpha) { } // intentionally left black};
}

function setupSplitLayout() {
	forceLayouter.charge(specialCharge);		
	forceLayouter.gravity(0.0);			
	
	return function(alpha) {
		var targetGravity = 0.3; // the gravity of the target locations
	
		nodes.each(function(d) {
			if (d.category2 === 0) {
				d.y = d.y + (targetY1 - d.y) * (targetGravity) * alpha * 1;
				d.x = d.x + (targetX1 - d.x) * (targetGravity) * alpha * 1;					
			}
			else if(d.category2 === 1) {
				d.y = d.y + (targetY2 - d.y) * (targetGravity) * alpha * 1;
				d.x = d.x + (targetX2 - d.x) * (targetGravity) * alpha * 1;
			}
			else if(d.category2 === 2) {
				d.y = d.y + (targetY3 - d.y) * (targetGravity) * alpha * 1;
				d.x = d.x + (targetX3 - d.x) * (targetGravity) * alpha * 1;
			}
			else {
				d.y = d.y + (targetY4 - d.y) * (targetGravity) * alpha * 1;
				d.x = d.x + (targetX4 - d.x) * (targetGravity) * alpha * 1;
			}
		});		
	};
}



// std d3 tick function copy and pasted from d3js.org
function forceTick(ev) {
	
	var alpha = ev.alpha;
	
	currentNodePositioner(alpha);
	
	nodes.each(function(d) {
		d.y += alpha * alpha *  50 * d[activeCategory];
	});
	
	nodes.attr("cx", function(d) { return d.x; }).attr("cy", function(d) { return d.y; });
}



function specialCharge(d) {
	return -(d.size*d.size*0.4);
}
	</pre>
	<p>.size property required otherwise centers on [0,0]</p>
	
	<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
	<script src="../dist/d3.js" charset="utf-8"></script>
	<script>
		var split = false;
		
		document.querySelector("#splitButton").addEventListener("click", function(ev){
			split = !split;	
			
			if(split) currentNodePositioner = setupSplitLayout();
			else currentNodePositioner = setupNormalLayout();
			
			forceLayouter.resume();
			
		});
		
		// Create a load of random data objects.
		var numDataPts = 500;
		var numCategory1s = 4;
		var numCategory2s = 2;
		var width = 1200, height = 800;
		
		var activeCategory = "category1";
		
		var data = [];
		for(var i = 0; i < numDataPts; i++) {
			data.push({ size: Math.random() * 20, category1: Math.floor(Math.random() * 4), category2:Math.floor(Math.random() * 4) });
		}
		// As there are so many nodes, initialize the starting y position to help the first layout 
		data.forEach(function(d) { d.y = height/2 + (50 * (d[activeCategory] - d[activeCategory]/2)) });
		
		
		// calculate the target locations for each category; note, in this example, three columns and number of rows depends on number of
		// categories. in this example, two rows.
		
		var targetX1 = 300, targetY1 = 200;
		var targetX2 = 900, targetY2 = 200;
		var targetX3 = 300, targetY3 = 600;
		var targetX4 = 600, targetY4 = 400;
		
		
		
		
		
		
		// create the container for the force layout chart
		var chart = d3.select("#chartArea").append("svg").attr("width", width).attr("height",height);
		
		// draw target circles on chart to show where the clusters should be
		var targets = [[targetX1,targetY1],[targetX2,targetY2],[targetX3,targetY3],[targetX4,targetY4]];
		chart.selectAll(".targetCircles").data(targets).enter().append("circle").attr("class", "targetCircles").attr("cx", function(d) { return d[0];} ).attr("cy", function(d) { return d[1];} ).attr("r", 100 )
		
		
		// this scale is used to colour nodes by category.
		var colourRamp = d3.scale.category10();
		
		// create a force layouter 
		var forceLayouter = d3.layout.force().size([width, height]).nodes(data).on("tick", forceTick);
		
		var currentNodePositioner = setupNormalLayout();			
		forceLayouter.start();
		
	
		// draw the nodes
		nodes = chart.selectAll(".nodes").data(data)
							.enter()
								.append("circle")
									.attr("class", "nodes")
									.attr("cx", function(d) { return d.x; })
									.attr("cy", function(d) { return d.y; })
									.attr("r", function(d) { return d.size; })
									.style("stroke", function(d) { return colourRamp(d[activeCategory])})
									.style("fill", function(d) { return colourRamp(d[activeCategory])});
												
		function setupNormalLayout() {
			forceLayouter.charge(specialCharge);		
			forceLayouter.gravity(0.3);			
			forceLayouter.chargeDistance(Number.POSITIVE_INFINITY);
			return function(alpha) { } // intentionally left black};
		}
		
		function setupSplitLayout() {
			forceLayouter.charge(specialCharge);		
			forceLayouter.gravity(0.0);			
			forceLayouter.chargeDistance(250);
			return function(alpha) {
				var targetGravity = 0.3; // the gravity of the target locations
			
				nodes.each(function(d) {
					if (d.category2 === 0) {
						d.y = d.y + (targetY1 - d.y) * (targetGravity) * alpha * 1;
						d.x = d.x + (targetX1 - d.x) * (targetGravity) * alpha * 1;					
					}
					else if(d.category2 === 1) {
						d.y = d.y + (targetY2 - d.y) * (targetGravity) * alpha * 1;
						d.x = d.x + (targetX2 - d.x) * (targetGravity) * alpha * 1;
					}
					else if(d.category2 === 2) {
						d.y = d.y + (targetY3 - d.y) * (targetGravity) * alpha * 1;
						d.x = d.x + (targetX3 - d.x) * (targetGravity) * alpha * 1;
					}
					else {
						d.y = d.y + (targetY4 - d.y) * (targetGravity) * alpha * 1;
						d.x = d.x + (targetX4 - d.x) * (targetGravity) * alpha * 1;
					}
				});		
			};
		}
		
		
		
		// std d3 tick function copy and pasted from d3js.org
		function forceTick(ev) {
			
			var alpha = ev.alpha;
			
			currentNodePositioner(alpha);
			
			nodes.each(function(d) {
				d.y += alpha * alpha *  50 * d[activeCategory];
			});
			
			nodes.attr("cx", function(d) { return d.x; }).attr("cy", function(d) { return d.y; });
		}
		
		
		
		function specialCharge(d) {
			return -(d.size*d.size*0.4);
		}
	
	</script>
</body>	
</html>